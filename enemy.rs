use crate::wasm4::*;
use crate::heart::{Heart, Point};
use crate::projectile::Projectile;

// sans
const SANS_WIDTH: u32 = 50;
const SANS_HEIGHT: u32 = 50;
const SANS_FLAGS: u32 = 0; // BLIT_1BPP
const SANS : [u8; 313] =[ 0xff,0xff,0xf8,0x01,0xff,0xff,0xff,0xff,0xf0,0x00,0x0f,0xff,0xff,0xff,0xf8,0x00,0x03,0xff,0xff,0xff,0xfc,0x00,0x00,0x3f,0xff,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0xff,0x80,0x00,0x01,0xff,0xff,0xff,0xe1,0xe0,0x7c,0x7f,0xff,0xff,0xf8,0xfc,0x3f,0x1f,0xff,0xff,0xfe,0x73,0x0c,0xe7,0xff,0xff,0xff,0x9c,0xc3,0x39,0xff,0xff,0xff,0xf3,0xe0,0x7c,0xff,0xff,0xff,0xfe,0x09,0x90,0x7f,0xff,0xff,0xff,0x84,0xf2,0x0f,0xff,0xff,0xff,0xc4,0x3c,0x23,0xff,0xff,0xff,0xf1,0x80,0x1c,0xff,0xff,0xff,0xfc,0x7f,0xfa,0x3f,0xff,0xff,0xff,0x09,0x4b,0x1f,0xff,0xff,0xfe,0x61,0xd3,0x8d,0xff,0xff,0xff,0x0e,0x1f,0x82,0x3f,0xff,0xff,0xb0,0xe0,0x07,0x1b,0xff,0xff,0xff,0x1f,0xff,0xce,0x7f,0xff,0xff,0xe1,0x83,0x86,0xcf,0xff,0xfd,0xde,0x31,0x8f,0x7b,0xff,0xfe,0xf7,0xb7,0xc7,0xde,0x3f,0xff,0x7d,0xef,0x3d,0xf7,0xe7,0xff,0xdf,0x78,0xc4,0x79,0xf9,0xff,0xf7,0xc0,0xd1,0x50,0x7e,0x7f,0xf9,0xf7,0xd4,0x43,0xcf,0x9f,0xfe,0x7d,0xf1,0x14,0xfb,0xf7,0xff,0xcf,0x7d,0x44,0xbe,0xf9,0xff,0xf9,0xdf,0x51,0x2f,0xbc,0x7f,0xff,0x37,0xd7,0xc7,0xee,0x7f,0xff,0xec,0xf8,0x03,0xf2,0x3f,0xff,0xfe,0x00,0x3e,0x01,0x9f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfa,0x7f,0xf7,0xdf,0xff,0xff,0xfd,0x1f,0xfc,0xf7,0xff,0xff,0xff,0x4f,0xef,0x3d,0xff,0xff,0xff,0xd3,0xf5,0xdf,0x7f,0xff,0xff,0xf4,0xfd,0x73,0xef,0xff,0xff,0xf9,0x7f,0x5c,0xfb,0xff,0xff,0xfe,0xdf,0x97,0x3e,0xff,0xff,0xff,0xb7,0xed,0xef,0xbf,0xff,0xff,0xed,0xfb,0x7b,0x8f,0xff,0xff,0xfc,0x00,0xe0,0x17,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x88,0xff,0x83,0x1f,0xff,0xff,0xc1,0x7f,0xe1,0x83,0xff,0xff,0xe0,0x3f,0xff,0xc0,0x7f,0xff,0xf8,0x09,0xfc,0x20,0x3f,0xf0 ];

pub struct Enemy {
    pub pos: Point,
    pub projectiles: Vec<Projectile>,
    shoot_timer: u32,
}

impl Enemy {
    pub fn new() -> Self {
        Self {
            pos: Point { x: 80, y: 20 },
            projectiles: Vec::new(),
            shoot_timer: 0,
        }
    }

    pub fn update(&mut self, heart: &mut Heart) {
        self.shoot_timer += 1;

        // A cada 60 frames, dispara
        if self.shoot_timer >= 60 {
            let proj = Projectile::new(self.pos, heart.body);
            self.projectiles.push(proj);
            self.shoot_timer = 0;
        }

        for proj in &mut self.projectiles {
            proj.update();
        }

        // Verifica colisões
        self.projectiles.retain(|p| {
            let px = p.pos.0 as i32 + 2; // deslocamento horizontal do centro (5 / 2)
            let py = p.pos.1 as i32 + 2; // deslocamento vertical do centro

            if heart.is_hit(px, py) && heart.life > 0 {
                heart.life -= 1;
                return false; // remove o projétil
            }

            p.is_on_screen()
        });
    }        

    pub fn draw(&self) {
        // Desenha inimigo como quadrado vermelho
        //unsafe { *DRAW_COLORS = 0x24 }
        //rect(self.pos.x - 5, self.pos.y - 5, 10, 10);

        unsafe { *DRAW_COLORS = 0x03 }
        blit(&SANS, 55, 10, SANS_WIDTH, SANS_HEIGHT, SANS_FLAGS);        

        for proj in &self.projectiles {
            proj.draw();
        }
    }
}
