use crate::wasm4::*;
use crate::heart::{Heart, Point};
use crate::projectile::{Projectile, ProjectileType};
use crate::bone_obstacle::{BoneObstacle, BoneType, G_HEIGHT};

// sans1
pub const SANS1_WIDTH: u32 = 50;
pub const SANS1_HEIGHT: u32 = 52;
pub const SANS1_FLAGS: u32 = 0; // BLIT_1BPP
pub const SANS1: [u8; 325] = [ 0xff,0xff,0xf8,0x01,0xff,0xff,0xff,0xff,0xf0,0x00,0x0f,0xff,0xff,0xff,0xf8,0x00,0x03,0xff,0xff,0xff,0xfc,0x00,0x00,0x3f,0xff,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0xff,0x80,0x00,0x01,0xff,0xff,0xff,0xe1,0xe0,0x7c,0x7f,0xff,0xff,0xf8,0xfc,0x3f,0x1f,0xff,0xff,0xfe,0x73,0x0c,0xe7,0xff,0xff,0xff,0x9c,0xc3,0x39,0xff,0xff,0xff,0xf3,0xe0,0x7c,0xff,0xff,0xff,0xfe,0x09,0x90,0x7f,0xff,0xff,0xff,0x84,0xf2,0x0f,0xff,0xff,0xff,0xc4,0x3c,0x23,0xff,0xff,0xff,0xf1,0x80,0x1c,0xff,0xff,0xff,0xfc,0x7f,0xfa,0x3f,0xff,0xff,0xff,0x09,0x4b,0x1f,0xff,0xff,0xff,0xe1,0xd3,0x8f,0xff,0xff,0xff,0xfe,0x1f,0x83,0xff,0xff,0xff,0xe7,0xe0,0x07,0xdf,0xff,0xff,0xf0,0xff,0xff,0xe3,0xff,0xff,0xfb,0x0f,0xff,0xf1,0xbf,0xff,0xff,0xf1,0xff,0xfc,0xe7,0xff,0xff,0xfe,0x18,0x38,0x6c,0xff,0xff,0xdd,0xe3,0x18,0xf7,0xbf,0xff,0xef,0x7b,0x7c,0x7d,0xe3,0xff,0xf7,0xde,0xf3,0xdf,0x7e,0x7f,0xfd,0xf7,0x8c,0x47,0x9f,0x9f,0xff,0x7c,0x0d,0x15,0x07,0xe7,0xff,0x9f,0x7d,0x44,0x3c,0xf9,0xff,0xe7,0xdf,0x11,0x4f,0xbf,0x7f,0xfc,0xf7,0xd4,0x4b,0xef,0x9f,0xff,0x9d,0xf5,0x12,0xfb,0xc7,0xff,0xf3,0x7d,0x7c,0x7e,0xe7,0xff,0xfe,0xcf,0x80,0x3f,0x23,0xff,0xff,0xe0,0x03,0xe0,0x19,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xa7,0xff,0x7d,0xff,0xff,0xff,0xd1,0xff,0xcf,0x7f,0xff,0xff,0xf4,0xfe,0xf3,0xdf,0xff,0xff,0xfd,0x3f,0x5d,0xf7,0xff,0xff,0xff,0x4f,0xd7,0x3e,0xff,0xff,0xff,0x97,0xf5,0xcf,0xbf,0xff,0xff,0xed,0xf9,0x73,0xef,0xff,0xff,0xfb,0x7e,0xde,0xfb,0xff,0xff,0xfe,0xdf,0xb7,0xb8,0xff,0xff,0xff,0xc0,0x0e,0x01,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x8f,0xf8,0x31,0xff,0xff,0xfc,0x17,0xfe,0x18,0x3f,0xff,0xfe,0x03,0xff,0xfc,0x07,0xff,0xff,0x80,0x9f,0xc2,0x03,0xff ];

// sans2
pub const SANS2_WIDTH: u32 = 50;
pub const SANS2_HEIGHT: u32 = 52;
pub const SANS2_FLAGS: u32 = 0; // BLIT_1BPP
pub const SANS2: [u8; 325] = [ 0xff,0xff,0xf8,0x01,0xff,0xff,0xff,0xff,0xf0,0x00,0x0f,0xff,0xff,0xff,0xf8,0x00,0x03,0xff,0xff,0xff,0xfc,0x00,0x00,0x3f,0xff,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0xff,0x80,0x00,0x01,0xff,0xff,0xff,0xe1,0xe0,0x7c,0x7f,0xff,0xff,0xf8,0xfc,0x3f,0x1f,0xff,0xff,0xfe,0x73,0x0c,0xe7,0xff,0xff,0xff,0x9c,0xc3,0x39,0xff,0xff,0xff,0xf3,0xe0,0x7c,0xff,0xff,0xff,0xfe,0x09,0x90,0x7f,0xff,0xff,0xff,0x84,0xf2,0x0f,0xff,0xff,0xff,0xc4,0x3c,0x23,0xff,0xff,0xff,0xf1,0x80,0x1c,0xff,0xff,0xff,0xfc,0x7f,0xfa,0x3f,0xff,0xff,0xff,0x09,0x4b,0x1f,0xff,0xff,0xff,0xe1,0xd3,0x8f,0xff,0xff,0xff,0x9e,0x1f,0x83,0x7f,0xff,0xff,0xc3,0xe0,0x07,0x8f,0xff,0xff,0xe0,0x3f,0xff,0xc6,0xff,0xff,0xff,0xc7,0xff,0xf3,0x9f,0xff,0xfd,0xf8,0x60,0xe1,0xb3,0xff,0xfe,0xf7,0x8c,0x63,0xde,0xff,0xff,0xfd,0xed,0xf1,0xf7,0x8f,0xff,0xdf,0x7b,0xcf,0x7d,0xf9,0xff,0xf7,0xde,0x31,0x1e,0x7e,0x7f,0xfd,0xf0,0x34,0x54,0x1f,0x9f,0xfe,0x7d,0xf5,0x10,0xf3,0xe7,0xff,0x9f,0x7c,0x44,0x3e,0xfd,0xff,0xf3,0xdf,0x51,0x2f,0xbe,0x7f,0xfe,0x77,0xd4,0x4b,0xef,0x1f,0xff,0xcd,0xf5,0xf1,0xfb,0x9f,0xff,0xfb,0x3e,0x00,0xfc,0x8f,0xff,0xff,0x80,0x0f,0x80,0x67,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xa7,0xff,0x7d,0xff,0xff,0xff,0xd1,0xff,0xcf,0x7f,0xff,0xff,0xf4,0xfe,0xf3,0xdf,0xff,0xff,0xfd,0x3f,0x5d,0xf7,0xff,0xff,0xff,0x4f,0xd7,0x3e,0xff,0xff,0xff,0x97,0xf5,0xcf,0xbf,0xff,0xff,0xed,0xf9,0x73,0xef,0xff,0xff,0xfb,0x7e,0xde,0xfb,0xff,0xff,0xfe,0xdf,0xb7,0xb8,0xff,0xff,0xff,0xc0,0x0e,0x01,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x8f,0xf8,0x31,0xff,0xff,0xfc,0x17,0xfe,0x18,0x3f,0xff,0xfe,0x03,0xff,0xfc,0x07,0xff,0xff,0x80,0x9f,0xc2,0x03,0xff ];

// sans3
pub const SANS3_WIDTH: u32 = 50;
pub const SANS3_HEIGHT: u32 = 52;
pub const SANS3_FLAGS: u32 = 0; // BLIT_1BPP
pub const SANS3: [u8; 325] = [ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x1f,0xff,0xff,0xff,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x80,0x00,0x3f,0xff,0xff,0xff,0xc0,0x00,0x03,0xff,0xff,0xff,0xf0,0x00,0x00,0xff,0xff,0xff,0xf8,0x00,0x00,0x1f,0xff,0xff,0xfe,0x1e,0x07,0xc7,0xff,0xff,0xff,0x8f,0xc3,0xf1,0xff,0xff,0xff,0xe7,0x30,0xce,0x7f,0xff,0xff,0xf9,0xcc,0x33,0x9f,0xff,0xff,0xff,0x3e,0x07,0xcf,0xff,0xff,0xff,0xe0,0x99,0x07,0xff,0xff,0xff,0xf8,0x4f,0x20,0xff,0xff,0xff,0xfc,0x43,0xc2,0x3f,0xff,0xff,0xff,0x18,0x01,0xcf,0xff,0xff,0xff,0xc7,0xff,0xa3,0xff,0xff,0xff,0xf0,0x94,0xb1,0xff,0xff,0xff,0xe6,0x1d,0x38,0xdf,0xff,0xff,0xf0,0xe1,0xf8,0x23,0xff,0xff,0xfb,0x0e,0x00,0x71,0xbf,0xff,0xff,0xf1,0xff,0xfc,0xe7,0xff,0xff,0xfe,0x18,0x38,0x6c,0xff,0xff,0xdd,0xe3,0x18,0xf7,0xbf,0xff,0xef,0x7b,0x7c,0x7d,0xe3,0xff,0xf7,0xde,0xf3,0xdf,0x7e,0x7f,0xfd,0xf7,0x8c,0x47,0x9f,0x9f,0xff,0x7c,0x0d,0x15,0x07,0xe7,0xff,0x9f,0x7d,0x44,0x3c,0xf9,0xff,0xe7,0xdf,0x11,0x4f,0xbf,0x7f,0xfc,0xf7,0xd4,0x4b,0xef,0x9f,0xff,0x9d,0xf5,0x12,0xfb,0xc7,0xff,0xf3,0x7d,0x7c,0x7e,0xe7,0xff,0xfe,0xcf,0x80,0x3f,0x23,0xff,0xff,0xe0,0x03,0xe0,0x19,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xa7,0xff,0x7d,0xff,0xff,0xff,0xd1,0xff,0xcf,0x7f,0xff,0xff,0xf4,0xfe,0xf3,0xdf,0xff,0xff,0xfd,0x3f,0x5d,0xf7,0xff,0xff,0xff,0x4f,0xd7,0x3e,0xff,0xff,0xff,0x97,0xf5,0xcf,0xbf,0xff,0xff,0xed,0xf9,0x73,0xef,0xff,0xff,0xfb,0x7e,0xde,0xfb,0xff,0xff,0xfe,0xdf,0xb7,0xb8,0xff,0xff,0xff,0xc0,0x0e,0x01,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x8f,0xf8,0x31,0xff,0xff,0xfc,0x17,0xfe,0x18,0x3f,0xff,0xfe,0x03,0xff,0xfc,0x07,0xff,0xff,0x80,0x9f,0xc2,0x03,0xff ];

#[derive(Clone, Copy, PartialEq)]
pub enum DifficultyLevel {
    Easy,
    EasyTransition,
    Medium,
    MediumTransition,
    Hard,
    Victory,
}

pub struct Enemy {
    #[allow(dead_code)]
    pub pos: Point,
    pub projectiles: Vec<Projectile>,
    pub bone_obstacles: Vec<BoneObstacle>,

    game_timer: u32,
    attack_timer: u32,
    pub difficulty: DifficultyLevel,
    victory_achieved: bool,
    pattern_timer: u32,
    pattern_active: bool,
    animation_timer: u32,
    animation_frame: usize,
}

impl Enemy {
    pub fn new() -> Self {
        Self {
            pos: Point { x: 80, y: 20 },
            projectiles: Vec::new(),
            bone_obstacles: Vec::new(),
            game_timer: 0,
            attack_timer: 0,
            difficulty: DifficultyLevel::Easy,
            victory_achieved: false,
            pattern_timer: 0,
            pattern_active: false,
            animation_timer: 0,
            animation_frame: 0,
        }
    }

    pub fn update(&mut self, heart: &mut Heart) {
        self.game_timer += 1;
        self.attack_timer += 1;
        self.pattern_timer += 1;
        self.animation_timer += 1;
        
        if self.animation_timer >= 15 {
            self.animation_timer = 0;
            self.animation_frame = (self.animation_frame + 1) % 3;
        }
        
        self.difficulty = match self.game_timer {
            0..=1800 => DifficultyLevel::Easy,           // 30s
            1801..=2400 => DifficultyLevel::EasyTransition, // 30s -> 40s (10s de transição)
            2401..=4200 => DifficultyLevel::Medium,      // 40s -> 70s (30s)
            4201..=4800 => DifficultyLevel::MediumTransition, // 70s -> 80s (10s de transição)
            4801..=6600 => DifficultyLevel::Hard,        // 80s -> 110s (30s) -> Duração total ajustada
            _ => {
                if !self.victory_achieved {
                    self.victory_achieved = true;
                }
                DifficultyLevel::Victory
            }
        };
        
        self.projectiles.retain_mut(|projectile| {
            projectile.update();
            
            if !projectile.is_on_screen() {
                return false;
            }
            
            if projectile.collides_with_heart(heart) {
                let damage = projectile.projectile_type.damage();
                if heart.take_damage(damage) {}
                return false;
            }
            
            true
        });
        
        self.bone_obstacles.retain_mut(|obstacle| {
            obstacle.update();

            if obstacle.is_off_screen() {
                return false;
            }

            if obstacle.collides_with_heart(heart) {
                if heart.take_damage(10) {}
                return false;
            }

            true
        });
        
        match self.difficulty {
            DifficultyLevel::Easy => self.easy_mode(heart),
            DifficultyLevel::EasyTransition => self.easy_transition_pattern(),
            DifficultyLevel::Medium => self.medium_mode(heart),
            DifficultyLevel::MediumTransition => self.medium_transition_pattern(),
            DifficultyLevel::Hard => self.hard_mode(heart),
            DifficultyLevel::Victory => {}
        }
    }
    
    pub fn reset(&mut self) {
        self.projectiles.clear();
        self.bone_obstacles.clear();
        self.game_timer = 0;
        self.attack_timer = 0;
        self.difficulty = DifficultyLevel::Easy;
        self.victory_achieved = false;
        self.pattern_timer = 0;
        self.pattern_active = false;
        self.animation_timer = 0;
        self.animation_frame = 0;
    }
    
    fn easy_mode(&mut self, heart: &Heart) {
        if self.attack_timer % 80 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.37) % 4.0) / 4.0;
            
            let projectile = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70, heart.body, ProjectileType::Small, edge_position, 20
            );
            self.projectiles.push(projectile);
        }
    }
    
    fn easy_transition_pattern(&mut self) {
        if !self.pattern_active {
            self.pattern_active = true;
            self.pattern_timer = 0;
        }
        
        if self.pattern_timer > 0 && self.pattern_timer % 50 == 0 && self.pattern_timer < 550 {
            let step = self.pattern_timer / 50;
            let from_left = step % 2 == 0;
            let sine_wave = (self.pattern_timer as f32 * 0.08).sin(); 
            let center_of_range = 93;
            let amplitude = 23;
            let y_pos = center_of_range + (sine_wave * amplitude as f32) as i32;
            
            let bone_type = if step % 2 == 0 { BoneType::P } else { BoneType::M };
            self.bone_obstacles.push(BoneObstacle::new(y_pos, from_left, bone_type, 1));
        }
        
        if self.pattern_timer > 600 {
            self.pattern_active = false;
        }
    }
    
    fn medium_mode(&mut self, heart: &Heart) {
        if self.attack_timer % 60 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.43) % 4.0) / 4.0;
            let projectile = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70, heart.body, ProjectileType::Small, edge_position, 18
            );
            self.projectiles.push(projectile);
        }
        
        if self.attack_timer % 120 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.71) % 4.0) / 4.0;
            let large_proj = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70, heart.body, ProjectileType::Large, edge_position, 25
            );
            self.projectiles.push(large_proj);
        }
        
        if self.attack_timer % 90 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.29) % 4.0) / 4.0;
            let fast_proj = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70, heart.body, ProjectileType::FastSmall, edge_position, 15
            );
            self.projectiles.push(fast_proj);
        }
    }
    
    fn medium_transition_pattern(&mut self) {
        if !self.pattern_active {
            self.pattern_active = true;
            self.pattern_timer = 0;

            self.projectiles.clear();
        }

        if self.pattern_timer > 0 && self.pattern_timer % 70 == 0 && self.pattern_timer < 600 {
            let step = self.pattern_timer / 70;
            
            let from_left = false;
            let gap_size = 40;
            let sine_wave = (self.pattern_timer as f32 * 0.05).sin();
            let gap_y_offset = (sine_wave * 15.0) as i32;
            let gap_y = 75 + 15 + gap_y_offset;
            let top_bone_type = if step % 2 == 0 { BoneType::G } else { BoneType::M };
            let bottom_bone_type = if step % 2 == 0 { BoneType::M } else { BoneType::G };
            let (_, _, top_bone_height) = top_bone_type.get_sprite_data();

            let bone_top = BoneObstacle::new(gap_y - top_bone_height as i32, from_left, top_bone_type, 3);
            let bone_bottom = BoneObstacle::new(gap_y + gap_size, from_left, bottom_bone_type, 3);

            self.bone_obstacles.push(bone_top);
            self.bone_obstacles.push(bone_bottom);
        }
        
        if self.pattern_timer > 600 {
            self.pattern_active = false;
        }
    }
    
    fn hard_mode(&mut self, heart: &Heart) {
        if self.attack_timer % 38 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.61) % 4.0) / 4.0;
            
            let projectile_type = match (self.attack_timer / 38) % 3 {
                0 => ProjectileType::Medium,
                1 => ProjectileType::Large,
                _ => ProjectileType::FastSmall,
            };
            
            let projectile = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70,
                heart.body,
                projectile_type,
                edge_position,
                14
            );
            self.projectiles.push(projectile);
        }
    }
    
    pub fn has_player_won(&self) -> bool {
        self.victory_achieved
    }

    fn get_current_sprite(&self) -> (&[u8], u32, u32, u32) {
        match self.animation_frame {
            0 => (&SANS1, SANS1_WIDTH, SANS1_HEIGHT, SANS1_FLAGS),
            1 => (&SANS2, SANS2_WIDTH, SANS2_HEIGHT, SANS2_FLAGS),
            2 => (&SANS3, SANS3_WIDTH, SANS3_HEIGHT, SANS3_FLAGS),
            _ => (&SANS1, SANS1_WIDTH, SANS1_HEIGHT, SANS1_FLAGS),
        }
    }
    
    pub fn draw(&self) {
        unsafe { *DRAW_COLORS = 0x03 }
        let (sprite_data, width, height, flags) = self.get_current_sprite();
        blit(sprite_data, 55, 10, width, height, flags);
        
        for proj in &self.projectiles {
            proj.draw();
        }
        
        for obstacle in &self.bone_obstacles {
            obstacle.draw();
        }
    }
}