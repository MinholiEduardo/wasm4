use crate::wasm4::*;
use crate::heart::{Heart, Point};
use crate::projectile::{Projectile, ProjectileType}; // Importa Laser do projectile

// sans1
pub const SANS1_WIDTH: u32 = 50;
pub const SANS1_HEIGHT: u32 = 52;
pub const SANS1_FLAGS: u32 = 0; // BLIT_1BPP
pub const SANS1: [u8; 325] = [ 0xff,0xff,0xf8,0x01,0xff,0xff,0xff,0xff,0xf0,0x00,0x0f,0xff,0xff,0xff,0xf8,0x00,0x03,0xff,0xff,0xff,0xfc,0x00,0x00,0x3f,0xff,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0xff,0x80,0x00,0x01,0xff,0xff,0xff,0xe1,0xe0,0x7c,0x7f,0xff,0xff,0xf8,0xfc,0x3f,0x1f,0xff,0xff,0xfe,0x73,0x0c,0xe7,0xff,0xff,0xff,0x9c,0xc3,0x39,0xff,0xff,0xff,0xf3,0xe0,0x7c,0xff,0xff,0xff,0xfe,0x09,0x90,0x7f,0xff,0xff,0xff,0x84,0xf2,0x0f,0xff,0xff,0xff,0xc4,0x3c,0x23,0xff,0xff,0xff,0xf1,0x80,0x1c,0xff,0xff,0xff,0xfc,0x7f,0xfa,0x3f,0xff,0xff,0xff,0x09,0x4b,0x1f,0xff,0xff,0xff,0xe1,0xd3,0x8f,0xff,0xff,0xff,0xfe,0x1f,0x83,0xff,0xff,0xff,0xe7,0xe0,0x07,0xdf,0xff,0xff,0xf0,0xff,0xff,0xe3,0xff,0xff,0xfb,0x0f,0xff,0xf1,0xbf,0xff,0xff,0xf1,0xff,0xfc,0xe7,0xff,0xff,0xfe,0x18,0x38,0x6c,0xff,0xff,0xdd,0xe3,0x18,0xf7,0xbf,0xff,0xef,0x7b,0x7c,0x7d,0xe3,0xff,0xf7,0xde,0xf3,0xdf,0x7e,0x7f,0xfd,0xf7,0x8c,0x47,0x9f,0x9f,0xff,0x7c,0x0d,0x15,0x07,0xe7,0xff,0x9f,0x7d,0x44,0x3c,0xf9,0xff,0xe7,0xdf,0x11,0x4f,0xbf,0x7f,0xfc,0xf7,0xd4,0x4b,0xef,0x9f,0xff,0x9d,0xf5,0x12,0xfb,0xc7,0xff,0xf3,0x7d,0x7c,0x7e,0xe7,0xff,0xfe,0xcf,0x80,0x3f,0x23,0xff,0xff,0xe0,0x03,0xe0,0x19,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xa7,0xff,0x7d,0xff,0xff,0xff,0xd1,0xff,0xcf,0x7f,0xff,0xff,0xf4,0xfe,0xf3,0xdf,0xff,0xff,0xfd,0x3f,0x5d,0xf7,0xff,0xff,0xff,0x4f,0xd7,0x3e,0xff,0xff,0xff,0x97,0xf5,0xcf,0xbf,0xff,0xff,0xed,0xf9,0x73,0xef,0xff,0xff,0xfb,0x7e,0xde,0xfb,0xff,0xff,0xfe,0xdf,0xb7,0xb8,0xff,0xff,0xff,0xc0,0x0e,0x01,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x8f,0xf8,0x31,0xff,0xff,0xfc,0x17,0xfe,0x18,0x3f,0xff,0xfe,0x03,0xff,0xfc,0x07,0xff,0xff,0x80,0x9f,0xc2,0x03,0xff ];

// sans2
pub const SANS2_WIDTH: u32 = 50;
pub const SANS2_HEIGHT: u32 = 52;
pub const SANS2_FLAGS: u32 = 0; // BLIT_1BPP
pub const SANS2: [u8; 325] = [ 0xff,0xff,0xf8,0x01,0xff,0xff,0xff,0xff,0xf0,0x00,0x0f,0xff,0xff,0xff,0xf8,0x00,0x03,0xff,0xff,0xff,0xfc,0x00,0x00,0x3f,0xff,0xff,0xff,0x00,0x00,0x0f,0xff,0xff,0xff,0x80,0x00,0x01,0xff,0xff,0xff,0xe1,0xe0,0x7c,0x7f,0xff,0xff,0xf8,0xfc,0x3f,0x1f,0xff,0xff,0xfe,0x73,0x0c,0xe7,0xff,0xff,0xff,0x9c,0xc3,0x39,0xff,0xff,0xff,0xf3,0xe0,0x7c,0xff,0xff,0xff,0xfe,0x09,0x90,0x7f,0xff,0xff,0xff,0x84,0xf2,0x0f,0xff,0xff,0xff,0xc4,0x3c,0x23,0xff,0xff,0xff,0xf1,0x80,0x1c,0xff,0xff,0xff,0xfc,0x7f,0xfa,0x3f,0xff,0xff,0xff,0x09,0x4b,0x1f,0xff,0xff,0xff,0xe1,0xd3,0x8f,0xff,0xff,0xff,0x9e,0x1f,0x83,0x7f,0xff,0xff,0xc3,0xe0,0x07,0x8f,0xff,0xff,0xe0,0x3f,0xff,0xc6,0xff,0xff,0xff,0xc7,0xff,0xf3,0x9f,0xff,0xfd,0xf8,0x60,0xe1,0xb3,0xff,0xfe,0xf7,0x8c,0x63,0xde,0xff,0xff,0xfd,0xed,0xf1,0xf7,0x8f,0xff,0xdf,0x7b,0xcf,0x7d,0xf9,0xff,0xf7,0xde,0x31,0x1e,0x7e,0x7f,0xfd,0xf0,0x34,0x54,0x1f,0x9f,0xfe,0x7d,0xf5,0x10,0xf3,0xe7,0xff,0x9f,0x7c,0x44,0x3e,0xfd,0xff,0xf3,0xdf,0x51,0x2f,0xbe,0x7f,0xfe,0x77,0xd4,0x4b,0xef,0x1f,0xff,0xcd,0xf5,0xf1,0xfb,0x9f,0xff,0xfb,0x3e,0x00,0xfc,0x8f,0xff,0xff,0x80,0x0f,0x80,0x67,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xa7,0xff,0x7d,0xff,0xff,0xff,0xd1,0xff,0xcf,0x7f,0xff,0xff,0xf4,0xfe,0xf3,0xdf,0xff,0xff,0xfd,0x3f,0x5d,0xf7,0xff,0xff,0xff,0x4f,0xd7,0x3e,0xff,0xff,0xff,0x97,0xf5,0xcf,0xbf,0xff,0xff,0xed,0xf9,0x73,0xef,0xff,0xff,0xfb,0x7e,0xde,0xfb,0xff,0xff,0xfe,0xdf,0xb7,0xb8,0xff,0xff,0xff,0xc0,0x0e,0x01,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x8f,0xf8,0x31,0xff,0xff,0xfc,0x17,0xfe,0x18,0x3f,0xff,0xfe,0x03,0xff,0xfc,0x07,0xff,0xff,0x80,0x9f,0xc2,0x03,0xff ];

// sans3
pub const SANS3_WIDTH: u32 = 50;
pub const SANS3_HEIGHT: u32 = 52;
pub const SANS3_FLAGS: u32 = 0; // BLIT_1BPP
pub const SANS3: [u8; 325] = [ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x1f,0xff,0xff,0xff,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x80,0x00,0x3f,0xff,0xff,0xff,0xc0,0x00,0x03,0xff,0xff,0xff,0xf0,0x00,0x00,0xff,0xff,0xff,0xf8,0x00,0x00,0x1f,0xff,0xff,0xfe,0x1e,0x07,0xc7,0xff,0xff,0xff,0x8f,0xc3,0xf1,0xff,0xff,0xff,0xe7,0x30,0xce,0x7f,0xff,0xff,0xf9,0xcc,0x33,0x9f,0xff,0xff,0xff,0x3e,0x07,0xcf,0xff,0xff,0xff,0xe0,0x99,0x07,0xff,0xff,0xff,0xf8,0x4f,0x20,0xff,0xff,0xff,0xfc,0x43,0xc2,0x3f,0xff,0xff,0xff,0x18,0x01,0xcf,0xff,0xff,0xff,0xc7,0xff,0xa3,0xff,0xff,0xff,0xf0,0x94,0xb1,0xff,0xff,0xff,0xe6,0x1d,0x38,0xdf,0xff,0xff,0xf0,0xe1,0xf8,0x23,0xff,0xff,0xfb,0x0e,0x00,0x71,0xbf,0xff,0xff,0xf1,0xff,0xfc,0xe7,0xff,0xff,0xfe,0x18,0x38,0x6c,0xff,0xff,0xdd,0xe3,0x18,0xf7,0xbf,0xff,0xef,0x7b,0x7c,0x7d,0xe3,0xff,0xf7,0xde,0xf3,0xdf,0x7e,0x7f,0xfd,0xf7,0x8c,0x47,0x9f,0x9f,0xff,0x7c,0x0d,0x15,0x07,0xe7,0xff,0x9f,0x7d,0x44,0x3c,0xf9,0xff,0xe7,0xdf,0x11,0x4f,0xbf,0x7f,0xfc,0xf7,0xd4,0x4b,0xef,0x9f,0xff,0x9d,0xf5,0x12,0xfb,0xc7,0xff,0xf3,0x7d,0x7c,0x7e,0xe7,0xff,0xfe,0xcf,0x80,0x3f,0x23,0xff,0xff,0xe0,0x03,0xe0,0x19,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xa7,0xff,0x7d,0xff,0xff,0xff,0xd1,0xff,0xcf,0x7f,0xff,0xff,0xf4,0xfe,0xf3,0xdf,0xff,0xff,0xfd,0x3f,0x5d,0xf7,0xff,0xff,0xff,0x4f,0xd7,0x3e,0xff,0xff,0xff,0x97,0xf5,0xcf,0xbf,0xff,0xff,0xed,0xf9,0x73,0xef,0xff,0xff,0xfb,0x7e,0xde,0xfb,0xff,0xff,0xfe,0xdf,0xb7,0xb8,0xff,0xff,0xff,0xc0,0x0e,0x01,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x8f,0xf8,0x31,0xff,0xff,0xfc,0x17,0xfe,0x18,0x3f,0xff,0xfe,0x03,0xff,0xfc,0x07,0xff,0xff,0x80,0x9f,0xc2,0x03,0xff ];

#[derive(Clone, Copy, PartialEq)]
pub enum DifficultyLevel {
    Easy,           // 0-30 segundos
    EasyTransition, // 30-35 segundos - Padrão de transição
    Medium,         // 35-65 segundos  
    MediumTransition, // 65-70 segundos - Padrão de transição
    Hard,           // 70-85 segundos (15 segundos como pedido)
    Victory,        // Completou tudo!
}

pub struct Enemy {
    #[allow(dead_code)]
    pub pos: Point,
    pub projectiles: Vec<Projectile>,

    game_timer: u32,
    attack_timer: u32,
    pub difficulty: DifficultyLevel,
    victory_achieved: bool,
    pattern_timer: u32,     // Timer para padrões especiais
    pattern_active: bool,   // Se um padrão está ativo
    animation_timer: u32,   // Timer para a animação idle
    animation_frame: usize, // Frame atual da animação
}

impl Enemy {
    pub fn new() -> Self {
        Self {
            pos: Point { x: 80, y: 20 },
            projectiles: Vec::new(),
            game_timer: 0,
            attack_timer: 0,
            difficulty: DifficultyLevel::Easy,
            victory_achieved: false,
            pattern_timer: 0,
            pattern_active: false,
            animation_timer: 0,
            animation_frame: 0,
        }
    }

    pub fn update(&mut self, heart: &mut Heart) {
        self.game_timer += 1;
        self.attack_timer += 1;
        self.pattern_timer += 1;
        self.animation_timer += 1;
        
        // Atualiza animação idle (muda de frame a cada 15 frames = ~0.25 segundos)
        if self.animation_timer >= 15 {
            self.animation_timer = 0;
            self.animation_frame = (self.animation_frame + 1) % 3; // Cicla entre 0, 1, 2
        }
        
        // Atualiza nível de dificuldade baseado no tempo
        // 30 segundos = 1800 frames (assumindo 60 FPS)
        self.difficulty = match self.game_timer {
            0..=1800 => DifficultyLevel::Easy,           // 0-30s
            1801..=2100 => DifficultyLevel::EasyTransition, // 30-35s (5s de transição)
            2101..=3900 => DifficultyLevel::Medium,      // 35-65s (30s)
            3901..=4200 => DifficultyLevel::MediumTransition, // 65-70s (5s de transição)
            4201..=5100 => DifficultyLevel::Hard,        // 70-85s (15s como pedido)
            _ => {
                if !self.victory_achieved {
                    self.victory_achieved = true;
                }
                DifficultyLevel::Victory
            }
        };
        
        // Atualiza projéteis existentes
        self.projectiles.retain_mut(|projectile| {
            projectile.update();
            
            if !projectile.is_on_screen() {
                return false;
            }
            
            if projectile.collides_with_heart(heart) {
                let damage = projectile.projectile_type.damage();
                if heart.take_damage(damage) {
                    // Dano foi aplicado com sucesso
                }
                return false;
            }
            
            true
        });
        
        // Ataques baseados na dificuldade
        match self.difficulty {
            DifficultyLevel::Easy => self.easy_mode(heart),
            DifficultyLevel::EasyTransition => self.easy_transition_pattern(heart),
            DifficultyLevel::Medium => self.medium_mode(heart),
            DifficultyLevel::MediumTransition => self.medium_transition_pattern(heart),
            DifficultyLevel::Hard => self.hard_mode(heart),
            DifficultyLevel::Victory => {}
        }
    }
    
    pub fn reset(&mut self) {
        self.projectiles.clear();
        self.game_timer = 0;
        self.attack_timer = 0;
        self.difficulty = DifficultyLevel::Easy;
        self.victory_achieved = false;
        self.pattern_timer = 0;
        self.pattern_active = false;
        self.animation_timer = 0;
        self.animation_frame = 0;
    }
    
    // MODO FÁCIL: Apenas bolinhas pequenas das bordas
    fn easy_mode(&mut self, heart: &Heart) {
        if self.attack_timer % 80 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.37) % 4.0) / 4.0;
            
            let projectile = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70,
                heart.body,
                ProjectileType::Small,
                edge_position,
                20
            );
            self.projectiles.push(projectile);
        }
    }
    
    // PADRÃO DE TRANSIÇÃO FÁCIL: Barragem de projéteis
    fn easy_transition_pattern(&mut self, heart: &Heart) {
        if !self.pattern_active {
            self.pattern_active = true;
            self.pattern_timer = 0;
        }
        
        // Cria barragens de projéteis em sequência
        if self.pattern_timer % 40 == 0 && self.pattern_timer < 200 { // 5 barragens
            let new_projectiles = Projectile::create_barrage_from_rectangle_with_distance(
                20, 70, 120, 70,
                heart.body,
                4, // 4 projéteis por barrage
                25
            );
            self.projectiles.extend(new_projectiles);
        }
        
        // Reset do padrão
        if self.pattern_timer > 300 {
            self.pattern_active = false;
            self.pattern_timer = 0;
        }
    }
    
    // MODO MÉDIO: Mix de projéteis
    fn medium_mode(&mut self, heart: &Heart) {
        if self.attack_timer % 60 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.43) % 4.0) / 4.0;
            
            let projectile = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70,
                heart.body,
                ProjectileType::Small,
                edge_position,
                18
            );
            self.projectiles.push(projectile);
        }
        
        if self.attack_timer % 120 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.71) % 4.0) / 4.0;
            
            let large_proj = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70,
                heart.body,
                ProjectileType::Large,
                edge_position,
                25
            );
            self.projectiles.push(large_proj);
        }
        
        if self.attack_timer % 90 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.29) % 4.0) / 4.0;
            
            let fast_proj = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70,
                heart.body,
                ProjectileType::FastSmall,
                edge_position,
                15
            );
            self.projectiles.push(fast_proj);
        }
    }
    
    // PADRÃO DE TRANSIÇÃO MÉDIO: Padrão circular de projéteis
    fn medium_transition_pattern(&mut self, heart: &Heart) {
        if !self.pattern_active {
            self.pattern_active = true;
            self.pattern_timer = 0;
        }
        
        // Padrão circular: projéteis vindo de todas as direções
        if self.pattern_timer % 30 == 0 && self.pattern_timer < 180 {
            let new_projectiles = Projectile::create_barrage_from_rectangle_with_distance(
                20, 70, 120, 70,
                heart.body,
                8, // Mais projéteis por vez
                30
            );
            self.projectiles.extend(new_projectiles);
        }
        
        if self.pattern_timer > 300 {
            self.pattern_active = false;
            self.pattern_timer = 0;
        }
    }
    
    // MODO DIFÍCIL: Ataques intensos + padrões ocasionais
    fn hard_mode(&mut self, heart: &Heart) {
        // Projéteis constantes mais rápidos
        if self.attack_timer % 35 == 0 {
            let edge_position = ((self.attack_timer as f32 * 0.61) % 4.0) / 4.0;
            
            let projectile_type = match (self.attack_timer / 35) % 3 {
                0 => ProjectileType::Small,
                1 => ProjectileType::Medium,
                _ => ProjectileType::FastSmall,
            };
            
            let projectile = Projectile::new_from_rectangle_edge_with_distance(
                20, 70, 120, 70,
                heart.body,
                projectile_type,
                edge_position,
                14
            );
            self.projectiles.push(projectile);
        }
        
        // Barrage mais frequente
        if self.attack_timer % 150 == 0 {
            let new_projectiles = Projectile::create_barrage_from_rectangle_with_distance(
                20, 70, 120, 70,
                heart.body,
                6, // Mais projéteis por barrage
                20
            );
            self.projectiles.extend(new_projectiles);
        }
    }
    
    pub fn has_player_won(&self) -> bool {
        self.victory_achieved
    }
    
    pub fn get_time_remaining_in_level(&self) -> u32 {
        let (current_phase_start, phase_duration): (u32, u32) = match self.difficulty {
            DifficultyLevel::Easy => (0, 1800),           // 30s
            DifficultyLevel::EasyTransition => (1800, 300), // 5s
            DifficultyLevel::Medium => (2100, 1800),      // 30s
            DifficultyLevel::MediumTransition => (3900, 300), // 5s
            DifficultyLevel::Hard => (4200, 900),         // 15s
            DifficultyLevel::Victory => return 0,
        };
        
        let elapsed_in_phase = self.game_timer.saturating_sub(current_phase_start);
        let remaining_frames = phase_duration.saturating_sub(elapsed_in_phase);
        remaining_frames / 60
    }
    
    pub fn get_total_time(&self) -> u32 {
        self.game_timer / 60
    }

    // Função auxiliar para obter o sprite atual da animação
    fn get_current_sprite(&self) -> (&[u8], u32, u32, u32) {
        match self.animation_frame {
            0 => (&SANS1, SANS1_WIDTH, SANS1_HEIGHT, SANS1_FLAGS),
            1 => (&SANS2, SANS2_WIDTH, SANS2_HEIGHT, SANS2_FLAGS),
            2 => (&SANS3, SANS3_WIDTH, SANS3_HEIGHT, SANS3_FLAGS),
            _ => (&SANS1, SANS1_WIDTH, SANS1_HEIGHT, SANS1_FLAGS), // fallback
        }
    }
    
    pub fn draw(&self) {
        // Desenha o Sans com animação
        unsafe { *DRAW_COLORS = 0x03 }
        let (sprite_data, width, height, flags) = self.get_current_sprite();
        blit(sprite_data, 55, 10, width, height, flags);
        
        // Desenha todos os projéteis
        for proj in &self.projectiles {
            proj.draw();
        }
        
        // Mostra nível atual e tempo
        unsafe { *DRAW_COLORS = 0x12 }
        let (level_name, time_remaining) = match self.difficulty {
            DifficultyLevel::Easy => ("EASY", self.get_time_remaining_in_level()),
            DifficultyLevel::EasyTransition => ("PATTERN", self.get_time_remaining_in_level()),
            DifficultyLevel::Medium => ("MEDIUM", self.get_time_remaining_in_level()),
            DifficultyLevel::MediumTransition => ("PATTERN", self.get_time_remaining_in_level()),
            DifficultyLevel::Hard => ("HARD", self.get_time_remaining_in_level()),
            DifficultyLevel::Victory => ("VICTORY!", 0),
        };
        
        text(level_name, 5, 5);
        
        if !matches!(self.difficulty, DifficultyLevel::Victory) {
            let time_text = format!("{}s", time_remaining);
            text(&time_text, 5, 15);
        } else {
            text("COMPLETED!", 5, 15);
        }
    }
}